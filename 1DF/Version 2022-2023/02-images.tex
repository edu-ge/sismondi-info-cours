
\documentclass[11pt, a4paper]{book}
\input{package.tex}
\pgfplotsset{compat=1.17}
\begin{document}

\setcounter{chapter}{1}
\chapter{Représentation numérique de l’information - Images}

\subsection{Image numérique}

Grâce aux nombres, les ordinateurs stockent des dessins, des photos et d’autres types d’images.
{\it Wikipedia} définit l'image numérique  comme toute image (dessin, icône, photographie…) acquise, créée, traitée et stockée sous forme binaire.

On distingue deux types d’images numériques:
\begin{enumerate}[a)]
\item {\bf L'image matricielle (ou bitmap}:
Elle est composée de points appelés pixels que l’on voit pas à l'œil nu. Lors de l’agrandissement l’image peut devenir floue car les pixels ressortent ( les carrés sur l’écran).
\item {\bf L'image vectorielle}:
Elle est composée de lignes et de segments qui sont liés entre eux par des formules mathématiques. Grâce à la vectorisation, chaque élément a une place définie qui empêche la déformation de l’image. Au lieu de mémoriser une mosaïque de points élémentaires, on stocke la succession d’opérations conduisant au tracé.

L’usage de ce type d’image concerne les schémas générés par certains logiciels de DAO(Dessin assisté par ordinateur) ou pour les animations Flash utilisées sur internet pour la création de bannières publicitaires.

\end{enumerate}

\begin{center}
\begin{figure}
\centering
\includegraphics[width=10cm]{images/bitmapvectoriel}
\caption{Différence entre une image bitmap (à gauche) et vectorielle (à droite)}
\end{figure}
\end{center}

\begin{remarque}

Il n’est pas possible de tout vectoriser car les photos et les dégradés de couleurs ne se vectorisent pas. En effet, la vectorisation aplatit les couleurs et élimine des dégradés.

\end{remarque}

\subsection{Coder une image en noir et blanc}

\subsubsection{Première méthode}

\begin{defi}
Les écrans d’ordinateur sont divisés en une grille de petits points appelés pixels (picture elements, qui signifie éléments d’image)
\end{defi}

Chaque pixel de l'image est codé soit par un 0, représentant un point blanc ou un 1, représentant un point noir. Donc un bit permet de coder un pixel d’une image en noir et blanc. 

Pour stocker une image en noir et blanc, il suffit de convertir le noir par 0 et le blanc par 1. 

\begin{center}
\begin{tikzpicture}[scale=.5]
\foreach \x in {0,...,8}
	{\draw (0,\x) -- +(8,0);
	\draw (\x,0) -- +(0,8);
	}
\foreach \x in {0,...,7}{
	\foreach \y in {0,...,7}{
			\draw (\x+.5,\y+.5)  node {$1$};
		}
	}	
	
\foreach \x in {(2,0),(3,0),(5,0),(6,0),
						(3,1),(4,1),(5,1),
						(2,2),(3,2),(5,2),(6,2),
						(2,3),(3,3),(5,3),(6,3),
						(3,4),(4,4),(5,4),
						(4,5),
						(2,6),(3,6),(4,6),(5,6),
						(3,7),(4,7),(5,7)
						}{
		\filldraw[fill=black] \x rectangle +(1,1);
		\draw[color=white] \x +(.5,.5) node {0};
}
	
\end{tikzpicture}
\end{center}

\subsubsection{Deuxième méthode}

Une autre façon consiste à indiquer pour chaque ligne le nombre de points blancs et de points noirs consécutifs.

\begin{center}
\begin{tikzpicture}[scale=.5]
\foreach \x in {0,...,5}
	{\draw (0,\x) -- +(5,0);
	\draw (\x,0) -- +(0,6);
	}
\draw (0,6) -- (5,6);
	
\foreach \x in {(1,0),(2,0),(3,0),(4,0),
						(0,1),(4,1),
						(0,2),(4,2),
						(1,3),(2,3),(3,3),(4,3),
						(4,4),
						(1,5),(2,5),(3,5)
						}{
		\filldraw[fill=black] \x rectangle +(1,1);
		
}
	
\draw (6,0.5) node[right] {1,4};	
\draw (6,1.5) node[right] {0,1,3,1};	
\draw (6,2.5) node[right] {0,1,3,1};	
\draw (6,3.5) node[right] {1,4};
\draw (6,4.5) node[right] {4,1};	
\draw (6,5.5) node[right] {1,3,1};		
	
\end{tikzpicture}
\end{center}

L’image de la lettre “a” nous montre comment une image peut être représentée par des nombres. Le premier nombre représente toujours le nombre de pixels blancs. Si le premier pixel est noir, la ligne commencera par un 0.
\begin{enumerate}[a)]
\item La première ligne est représentée par 1, 3, 1.
\item La première ligne contient 1 pixel blanc, 3 noirs puis 1 blanc. 
\item La quatrième ligne est représentée par 0, 1, 3, 1.
\end{enumerate}

\begin{exercice}
Décoder l'image suivante:

\begin{center}
\begin{tikzpicture}[scale=.5]
\foreach \x in {0,...,16}{
	\draw (\x,0) -- +(0,9);
	}

\foreach \x in {0,...,9}{
	\draw (0,\x) -- +(16,0);
	}

\draw (17,8.5) node[right] {4,11}; 
\draw (17,7.5) node[right] {4,9,2,1}; 
\draw (17,6.5) node[right] {4,9,2,1}; 
\draw (17,5.5) node[right] {4,11}; 
\draw (17,4.5) node[right] {4,9}; 
\draw (17,3.5) node[right] {4,9}; 
\draw (17,2.5) node[right] {5,7}; 
\draw (17,1.5) node[right] {0,16}; 
\draw (17,0.5) node[right] {1,14}; 	

\end{tikzpicture}
\end{center}
\end{exercice}


\subsection{Coder une image en couleur}

Pour stocker une image en couleur en mémoire, il suffit de convenir que chaque point de l’image est représenté par un nombre. 

Ce dernier correspond à une certaine couleur.

Pour une image en 16 couleurs, il faut que chaque point de l’image soit codé par un nombre en 4 bits.

Si chaque point est codé sur 8 bits l’image peut contenir 256 couleurs différentes.

Si l'on souhaite que l'image contient plus de couleurs, on pourra utiliser plus de bits pour chaque pixel.

Pour représenter des images avec des couleurs réalistes,
le code le plus utilisé est le codage {\bf RVB} (Rouge, Vert, Bleu) (RGB en anglais). 

Chacune de ces couleurs est codée sur 1 octet (8 bits). 
Avec ce système, chaque pixel est codé sur 3 octets pour un total de 24 bits. 

La valeur décimale pour chaque couleur peut s’étendre de 0 à 255, cette limite est fixée par la valeur maximale qu’un octet peut représenter avec le système binaire.

L’avantage du système RVB est sa simplicité, 
il s’appuie sur les caractéristiques de la vision humaine pour fournir à l’utilisateur une reproduction des couleurs au plus proche de la réalité.

\begin{center}
\begin{tikzpicture}[scale=.5]
\foreach \x in {0,...,10}{
	\draw (0,\x) -- +(30,0);
	} 

\draw (6,0) -- +(0,10);
\draw (14,0) -- +(0,10);
\draw (22,0) -- +(0,10);
\draw (30,0) -- +(0,10);
\draw (0,0) -- +(0,10);

\filldraw[fill=lightgray] (6,9) rectangle (30,10);

\draw (18,10.5) node {codage pixel en décimal};

\filldraw[fill=black] (0,0) rectangle (6,1);
\draw[white] (3,0.5) node {Noir};
\draw (10,0.5) node {0};
\draw (18,0.5) node {0};
\draw (26,0.5) node {0};

\definecolor{magenta}{rgb}{255,0,255}

\filldraw[fill=magenta] (0,1) rectangle +(6,1);
\draw (3,1.5) node {Magenta};
\draw (10,1.5) node {255};
\draw (18,1.5) node {0};
\draw (26,1.5) node {255};


\filldraw[fill=blue] (0,2) rectangle +(6,1);
\draw[white] (3,2.5) node {Bleu};
\draw (10,2.5) node {0};
\draw (18,2.5) node {0};
\draw (26,2.5) node {255};

\definecolor{cyan}{rgb}{0,255,255}

\filldraw[fill=cyan] (0,3) rectangle +(6,1);
\draw (3,3.5) node {Cyan};
\draw (10,3.5) node {0};
\draw (18,3.5) node {255};
\draw (26,3.5) node {255};

\filldraw[fill=green] (0,4) rectangle +(6,1);
\draw (3,4.5) node {Vert};
\draw (10,4.5) node {0};
\draw (18,4.5) node {255};
\draw (26,4.5) node {0};

\definecolor{jaune}{rgb}{255,255,0}

\filldraw[fill=jaune] (0,5) rectangle +(6,1);
\draw (3,5.5) node {Jaune};
\draw (10,5.5) node {255};
\draw (18,5.5) node {255};
\draw (26,5.5) node {0};

\filldraw[fill=red] (0,6) rectangle +(6,1);
\draw (3,6.5) node {Rouge};
\draw (10,6.5) node {255};
\draw (18,6.5) node {0};
\draw (26,6.5) node {0};

\filldraw[fill=white] (0,7) rectangle +(6,1);
\draw (3,7.5) node {Blanc};
\draw (10,7.5) node {255};
\draw (18,7.5) node {255};
\draw (26,7.5) node {255};

\filldraw[fill=gray] (0,8) rectangle +(6,1);
\draw (3,8.5) node {Gris moyen};
\draw (10,8.5) node {127};
\draw (18,8.5) node {127};
\draw (26,8.5) node {127};


\draw (3,9.5) node {\bf Couleur};
\draw (10,9.5) node {\bf R};
\draw (18,9.5) node {\bf V};
\draw (26,9.5) node {\bf B};

\end{tikzpicture}
\end{center}

Comme pour les systèmes de codage noir \& blanc et en niveau de gris, le système RVB utilise une norme pour le codage des couleurs. 

Le codage sur 16 bits permet d'obtenir 65536 couleurs différentes. 
Le codage sur 24 bits permet d'obtenir plus de 16 millions de couleurs ($2^{24}$ couleurs).

On considère souvent qu'un codage sur 32 bits permet de coder plus de couleurs que l’œil humain peut en distinguer.

Une photo de haute qualité est codée sur 32 bits.

On peut se contenter de 24 bits (soit 3 octets). Chaque octet représente une nuance des trois couleurs (rouge, vert et bleu), qui sont mélangées.

\subsubsection{Compression}

\begin{remarque}
La taille (poids) de l’image augmente en augmentant le nombre de nuances de couleurs.
\end{remarque}


Une technique consistent à réduire l’information nécessaire pour représenter une image ou un son.

Pour pallier les inconvénients des images trop lourdes en particulier lors du stockage ou de la transmission et publication sur le web.

Ce qui permet de réduire les exigences quant à l’espace disponible sur le disque ainsi que les coûts de communications lorsque l’image ou le son sont téléchargés.


Malgré les techniques de compression, les images ou sons occupent encore souvent une place importante dans le programme.

\subsubsection{Les formats d'images}

\begin{defi}
Un format d'image est une représentation informatique de l'image, associée à des informations sur la façon dont l'image est codée et fournissant éventuellement des indications sur la manière de la décoder et de la manipuler.
\end{defi}

Voici quelques formats d'images très utilisés:
\begin{enumerate}[a)]

\item {\bf BMP} : (prononcé {\it bitmap})	pas de compression, profondeur de couleurs au choix
\item {\bf JPG ou JPEG} : (prononcé {\it j-peg})	compression possible ; qualité entre 0 et 100\%. Perte de qualité. Profondeur de 
couleurs au choix. Bien adapté aux photos.
\item {\bf GIF} :	compression sans perte de qualité. 256 couleurs max.
\item {\bf PNG} :	compression sans perte. Intéressant pour les images avec peu de couleurs 
(schémas), mais pas pour des photos.

\end{enumerate}


\section{Représentation du son}
\subsubsection{Échantillonage}

Un son est un signal physique qui correspond à la pression de l'air au cours du temps. C'est ces variations de pressions que captent nos oreilles. Une fois enregistré, ce son peut-être encodé de manière similaire aux images : on sélectionne une valeur à intervalles de temps régulières et on encode chacune de ces valeurs en binaire. Cela revient à "pixeliser" le son.


\begin{center}
\begin{figure}[h!]
\includegraphics[width=12cm]{images/son}
\end{figure}
\end{center}

Ce processus est nommé l'échantillonnage et on échantillonne en général les sons à 44 kHz (ce qui correspond à une valeur toutes les 1/44000 secondes, soit toutes les 23 $\mu s$), soit 2x plus que le son le plus aigu que l'oreille humaine peut entendre (22kHz).

\subsubsection{Les formats d'images}
\begin{enumerate}
\item Cette technique est celle utilisée dans certains formats de sons "bruts" comme le RAW ou WAV. 

\item D'autres formats comme le MP3, compressent encore ces informations, comme le fait le JPG pour les images.

\item D'autres formats, comme le MIDI, n'utilise pas cette méthode et font le choix de noter directement l'équivalent des notes de musique et des instruments sur lesquels elles sont jouées. Ce format est adapté aux musiques composées sur synthétiseurs, mais pas aux sons enregistrés dans la nature.

\end{enumerate}

\section{Exercices}
\begin{exercice}
Traduire les mots suivants en code ASCII binaire :
\begin{enumerate}
\item \#MeToo
\item 2+2<5
\end{enumerate}
\end{exercice}


\begin{exercice}
Traduire en lettres la phrase suivante qui est codée en ASCII (binaire):
\begin{enumerate}
\item 01000011 01100001 00100000 01100011 00100111 01100101 01110011 01110100 00100000 01100100 01110101 00100000 01100010 01101001 01101110 01100001 01101001 01110010 01100101 00101110
\end{enumerate}
\end{exercice}

\begin{exercice}
Traduire en lettre les mots suivants qui sont codés en ASCII (hexadécimal):
\begin{enumerate}
\item 42696E76656E7521
\item 31323D332A342C204F4B3F
\end{enumerate}
\end{exercice}


\begin{exercice}
Décoder l'image suivante:

\begin{center}
\begin{tikzpicture}[scale=.5]
\foreach \x in {0,...,16}{
	\draw (\x,0) -- +(0,13);
	}

\foreach \x in {0,...,13}{
	\draw (0,\x) -- +(16,0);
	}

\draw (17,12.5) node[right] {6,5,2,3}; 
\draw (17,11.5) node[right] {4,2,5,2,3,1}; 
\draw (17,10.5) node[right] {3,1,9,1,2,1}; 
\draw (17,9.5) node[right] {3,1,9,1,1,1}; 
\draw (17,8.5) node[right] {2,1,11,1}; 
\draw (17,7.5) node[right] {2,1,10,2}; 
\draw (17,6.5) node[right] {2,1,9,1,1,1}; 
\draw (17,5.5) node[right] {2,1,8,1,2,1}; 
\draw (17,4.5) node[right] {2,1,7,1,3,1}; 
\draw (17,3.5) node[right] {1,1,1,1,4,2,3,1}; 	
\draw (17,2.5) node[right] {0,1,2,1,2,2,5,1}; 	
\draw (17,1.5) node[right] {0,1,3,2,5,2}; 	
\draw (17,0.5) node[right] {1,3,2,5}; 	

\end{tikzpicture}
\end{center}
\end{exercice}

\newpage
\begin{exercice}
Encoder l'image suivante:

\begin{center}
\begin{figure}[h!]
\includegraphics[width=8cm]{images/moustache}
\end{figure}
\end{center}

\end{exercice}


\begin{exercice}
Quel est d'après vous le code RGB du violet foncé ? %160-0-160
\end{exercice}


\begin{exercice}
Quel est d'après vous la couleur correspondant au code RGB suivant : (255, 128, 0) ? % orange
\end{exercice}

\end{document}